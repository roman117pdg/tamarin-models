theory 5G_AKA_protocol
begin

builtins: asymmetric-encryption, multiset, xor

functions: f1/2, f1_s/2, f2/2, f3/2, f4/2, f5/2, f5_s/2, KDF/2, SHA256/2


//--------------------------------------------------------------------------------//
//                              Initialization rules                              //
//--------------------------------------------------------------------------------//


rule initializeLtk:  // long term key shared beetwen UE and HN
  [ Fr(~ltk) ]
  -->
  [ !Ltk(~ltk,$UE,$HN) ]

rule revealLtsk:
  [ !Ltsk(ltsk,$UE,$HN) ]
  --[Reveal(ltsk)]->
  [ Out(ltsk)]

rule initializeSQN:  // sequence number
  [ Fr(~sqn) ]
  -->
  [ !SQN(~sqn,$UE,$HN) ]

rule revealSQN:
  [ !SQN(sqn,$UE,$HN) ]
  --[Reveal(<'SQN',sqn>)]->
  [Out(sqn)]


//--------------------------------------------------------------------------------//
//                             Stations initialization                            //
//                                UE     SN     HN                                //
//--------------------------------------------------------------------------------//


rule initialize_HN:
  let
    hn_pub_sk = pk(~hn_sk)
  in
  [ Fr(~hn_supi),
    Fr(~hn_sk),
    !Ltk(hn_ltk,$UE,$HN),
    !SQN(hn_sqn,$UE,$HN) ]
  --[ Create($HN, ~hn_supi, 'HN') ]->
  [ St_HN_0($HN, ~hn_supi, hn_ltk, hn_sqn, ~hn_sk),
  Out(<'HN_PK',~hn_supi, hn_pub_sk>) ]

rule initialize_SN:
  [  Fr(~id) 
  ]
  --[ Create($SN, ~id, 'SN') ]->
  [ St_SN_0($SN, ~id) ]

rule initialize_UE:
  [ Fr(~ue_supi),
    !Ltk(ue_ue_ltk,$UE,$HN),
    !SQN(ue_sqn, $UE,$HN),
    In(<'HN_PK', hn_supi, hn_pub_sk>) ]
  --[ Create($UE, ~ue_supi, 'UE') ]->
  [ St_UE_0($UE, ~ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk) ]


//--------------------------------------------------------------------------------//
//                                    MESSAGE 1                                   //
//                              <'Identity Request'>                              //
//                                UE <-- SN     HN                                //
//--------------------------------------------------------------------------------//

rule 1_SN_send_to_UE:
  let
    m = 'IdentityRequest'
  in
  [ St_SN_0($SN, ~id) ]
  --[ Send($SN, m),
      Station('SN'),
      StartExchange(m) ]->
  [ Out(m)
  , St_SN_1($SN, ~id)
  ]

rule 1_UE_receive_from_SN:
  [ St_UE_0($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk)
  , In(m)
  ]
  --[ Receive($UE, m),
      Station('UE') ]->
  [ St_UE_1($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk) ]


//--------------------------------------------------------------------------------//
//                                    MESSAGE 2                                   //
//                                     <SUCI>                                     //
//                                UE --> SN     HN                                //
//--------------------------------------------------------------------------------//


rule 2_UE_send_to_SN:
  let
    ue_supi_enc1 = aenc(ue_supi, hn_pub_sk)  // funkction aenc can't encrypt two variables
    ue_supi_enc2 = aenc(~ue_R, hn_pub_sk)
    suci = <<ue_supi_enc1, ue_supi_enc2>, hn_supi>
  in
  [ Fr(~ue_R), 
    St_UE_1($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk) ]
  --[ Send($UE, suci),
      Station('UE')]->
  [ St_UE_2($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk)
  , Out(suci)
  ]

rule 2_SN_receive_from_UE:
  [ In(suci),
    St_SN_1($SN, id)]
  --[ Receive($SN, suci),
      Station('SN') ]->
  [ St_SN_2($SN, id, suci)
  ]


//--------------------------------------------------------------------------------//
//                                    MESSAGE 3                                   //
//                                 <SUCI, SNname>                                 //
//                                UE     SN --> HN                                //
//--------------------------------------------------------------------------------//


rule 3_SN_send_to_HN:
  let
    suci = <ue_supi_enc, hn_supi>
    suciSN = <ue_supi_enc, id>  
  in
  [ St_SN_2($SN, id, suci)]
  --[ Send($SN, suciSN),
      Station('SN') ]->
  [ St_SN_3($SN, id, suci)
  , Out(suciSN)
  ]

rule 3_HN_receive_from_SN:
let
  ue_supi = adec(ue_supi_enc1, hn_sk) 
  ue_R = adec(ue_supi_enc2, hn_sk) 
  ue_supi_enc = <ue_supi_enc1, ue_supi_enc1>
  suciSN = <ue_supi_enc, sn_id>
in
  [ St_HN_0($HN, hn_supi, hn_ltk, hn_sqn, hn_sk),
    In(suciSN)]
  --[ Receive($HN, suciSN),
      Station('HN'),
      EndInitialization(suciSN) ]->
  [ St_HN_1($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id)]


//--------------------------------------------------------------------------------//
//                                    MESSAGE 4                                   //
//                            <R, AUTN, HXRES*, K_SEAF>                           //
//                                UE     SN <-- HN                                //
//--------------------------------------------------------------------------------//


rule 4_HN_send_to_SN:
let
  MAC = f1(hn_ltk, <hn_sqn,~R>)
  AK = f5(hn_ltk, ~R)

  CONC = hn_sqn XOR AK
  AUTN = <CONC, MAC>

  RES = f2(hn_ltk, ~R)
  CK = f3(hn_ltk, ~R)
  IK = f4(hn_ltk, ~R)
  RES_s = KDF(<CK, IK>, <sn_id, ~R, RES>)
  xRES_s = RES_s
  HRES_s = SHA256(~R, RES_s)

  K_AUSF = KDF(<CK, IK>, <sn_id, CONC>)
  K_SEAF = KDF(K_AUSF, sn_id)
  hn_sqn = hn_sqn + '1'

  msg_out = <~R, AUTN, HRES_s, K_SEAF>
in
  [ Fr(~R),
  St_HN_1($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id) ]
  --[ Send($HN, msg_out),
      Station('HN'),
      Secret(MAC),
      Secret(~R),
      Secret(hn_sqn),
      Honest($SN),
      Honest($UE) ]->
  [ Out(msg_out),
  St_HN_2($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s)]

rule 4_SN_receive_from_HN:
let
  msg_in = <R, AUTN, HRES_s, K_SEAF>
in
  [ In(msg_in),
    St_SN_3($SN, id, suci) ]
   --[Receive($SN, msg_in),
      Station('SN')]-> 
   [  St_SN_4($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]


//--------------------------------------------------------------------------------//
//                                    MESSAGE 5                                   //
//                                    <R, AUTN>                                   //
//                                UE <-- SN     HN                                //
//--------------------------------------------------------------------------------//


rule 5_SN_send_to_UE:
let
  msg_out = <R, AUTN, id>
in
  [ St_SN_4($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]
   --[Send($SN, msg_out),
      Station('SN')]-> 
  [ Out(msg_out),
    St_SN_5($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]

rule 5_UE_receive_from_SN:
let
  AK  = f5(ue_ue_ltk, R)
  xhn_sqn = xCONC XOR AK
  MAC = f1(ue_ue_ltk, <xhn_sqn, R>)
  AUTN = <xCONC, xMAC>
  msg_in = <R, AUTN, sn_id>
in
  [ In(msg_in),
    St_UE_2($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk) ]
  --[ Receive($UE, MAC),
      Station('UE') ]->
  [ St_UE_3($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 6.1                                  //
//                                EXPECTED RESPONSE                               //
//                      CHECK: xMAC == MAC && xSQN_HN > SQN_UE                    //
//                           <'ExpectedResponse', RES*>                           //
//                                UE --> SN     HN                                //
//--------------------------------------------------------------------------------//


rule 6_1_UE_send_to_SN:
let
  RES = f2(ue_ue_ltk, R)
  CK = f3(ue_ue_ltk, R)
  IK = f4(ue_ue_ltk, R)
  RES_s = KDF(<CK, IK>, <sn_id, R, RES>)
  msg_out = <'ExpectedResponse', RES_s>

  K_AUSF = KDF(<CK, IK>, <sn_id, xCONC>)
  K_SEAF = KDF(K_AUSF, sn_id)
in
  [ St_UE_3($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]
  --[ Send($UE, msg_out),
      Station('UE'),
      Secret(MAC),
      Secret(R),
      Secret(ue_sqn),
      Honest($SN),
      Honest($HN),
      Authentic($UE, MAC),
      Eq(xMAC, MAC),
      GreaterThan(xhn_sqn, ue_sqn) ]->
  [ Out(msg_out),
    St_UE_4_1_additional_st($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]

rule 6_1_UE_additional_st:
let
  ue_sqn = xhn_sqn
in
  [ St_UE_4_1_additional_st($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]
  -->
  [ St_UE_4_1($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]


rule 6_1_SN_receive_from_UE:
let
  msg_in = <msg_type, RES_s> 
in
  [ In(msg_in), 
    St_SN_5($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]
    --[ Receive($SN, msg_in),
        Station('SN'),
        Eq(msg_type, 'ExpectedResponse') ]->
  [ St_SN_6_1($SN, id, suci, R, AUTN, HRES_s, K_SEAF, RES_s) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 6.2                                  //
//                             SYNCHRONIZATION FAILURE                            //
//                     CHECK: xMAC == MAC && xSQN_HN <= SQN_UE                    //
//                        <'SynchronizationFailure', MACS>                        //
//                                UE --> SN     HN                                //
//--------------------------------------------------------------------------------//


rule 6_2_UE_send_to_SN:
let
  AUTS = <(ue_sqn XOR AKS), MACS>
  AKS = f5_s(ue_ue_ltk, R)
  MACS = f1_s(ue_ue_ltk, <ue_sqn, R>)
  msg_out = <'SynchronizationFailure', MACS>
in
  [ St_UE_3($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]
  --[ Send($UE, msg_out),
      Station('UE'),
      Eq(xMAC, MAC),
      SmallerOrEqualThan(xhn_sqn, ue_sqn)
       ]->
  [ Out(msg_out),
    St_UE_4_2($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]

rule 6_2_SN_receive_from_UE:
let
  msg_in = <msg_type, MACS> 
in
  [ In(msg_in), 
    St_SN_5($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]
    --[ Receive($SN, msg_in),
        Station('SN'),
        Eq(msg_type, 'SynchronizationFailure') ]->
  [ St_SN_6_2($SN, id, suci, R, AUTN, HRES_s, K_SEAF, MACS) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 6.3                                  //
//                                   MAC FAILURE                                  //
//                               CHECK: xMAC != MAC                               //
//                                 <'MAC_FAILURE'>                                //
//                                UE --> SN     HN                                //
//--------------------------------------------------------------------------------//


rule 6_3_UE_send_to_SN:
let
  msg_out = 'MacFailure'
in
  [ St_UE_3($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]
  --[ Send($UE, msg_out),
      Station('UE'),
      Neq(xMAC, MAC) ]->
  [ Out(msg_out),
    St_UE_4_3($UE, ue_supi, ue_ue_ltk, ue_sqn, hn_supi, hn_pub_sk, sn_id ,xhn_sqn, R, xCONC, MAC, xMAC) ]

rule 6_3_SN_receive_from_UE:
  [ In(msg_in), 
    St_SN_5($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]
    --[ Receive($SN, msg_in),
        Station('SN'),
        Eq(msg_in, 'MacFailure'),
        EndMacFailure(msg_in) ]->
  [ St_SN_6_3($SN, id, suci, R, AUTN, HRES_s, K_SEAF) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 7.1                                  //
//                                EXPECTED RESPONSE                               //
//                                  <RES*, SUCI>                                  //
//                                UE     SN --> HN                                //
//--------------------------------------------------------------------------------//


rule 7_1_SN_send_to_HN:
let
  xHRES_s = SHA256(R, RES_s)
  msg_out = <'ExpectedResponse', <RES_s, suci>>
in
  [ St_SN_6_1($SN, id, suci, R, AUTN, HRES_s, K_SEAF, RES_s) ]
    --[ Send($SN, msg_out),
        Station('SN'),
        Eq(HRES_s, xHRES_s) ]->
  [ Out(msg_out),
    St_SN_7_1($SN, id, suci, R, AUTN, HRES_s, K_SEAF, RES_s) ]

rule 7_1_HN_receive_from_SN:
let
  msg_in = <msg_type, <RES_s, suci>>
in
  [ In(msg_in),
    St_HN_2($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s) ]
    --[ Receive($HN, msg_in), 
        Station('HN'),
        Eq(msg_type, 'ExpectedResponse') ]->
  [ St_HN_3_1($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s, RES_s) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 7.2                                  //
//                             SYNCHRONIZATION FAILURE                            //
//                   <'SynchronizationFailure', MACS, R, SUCI>                    //
//                                UE     SN --> HN                                //
//--------------------------------------------------------------------------------//


rule 7_2_SN_send_to_HN:
let
  msg_out = <'SynchronizationFailure', <MACS, R, suci>>
in
  [ St_SN_6_2($SN, id, suci, R, AUTN, HRES_s, K_SEAF, MACS) ]
    --[ Send($SN, msg_out),
        Station('SN'),
        EndSynchronizationFailure(msg_out) ]->
  [ Out(msg_out),
    St_SN_7_2($SN, id, suci, R, AUTN, HRES_s, K_SEAF, MACS) ]

rule 7_2_HN_receive_from_SN:
let
  msg_in = <msg_type, <MACS, R, suci>>
in
  [ In(msg_in),
    St_HN_2($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s) ]
    --[ Receive($HN, msg_in), 
        Station('HN'),
        Eq(msg_type, 'SynchronizationFailure') ]->
  [ St_HN_3_2($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s) ]


//--------------------------------------------------------------------------------//
//                                   MESSAGE 8.1                                  //
//                                EXPECTED RESPONSE                               //
//                                     <SUPI>                                     //
//                                UE     SN <-- HN                                //
//--------------------------------------------------------------------------------//


rule 8_1_HN_send_to_SN:
  [ St_HN_3_1($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s, RES_s) ]
    --[ Send($HN, ue_supi),
        Station('HN'),
        Eq(xRES_s, RES_s) ]->
  [ Out(ue_supi),
    St_HN_4_1($HN, hn_supi, hn_ltk, hn_sqn, hn_sk, ue_supi, sn_id, xRES_s, RES_s) ]

rule 8_1_SN_receive_from_HN:
  [ In(ue_supi),
    St_SN_7_1($SN, id, suci, R, AUTN, HRES_s, K_SEAF, RES_s) ]
    --[ Receive($SN, ue_supi),
        Station('SN'),
        EndExpectedResponse(ue_supi) ]->
  [ St_SN_8_1($SN, id, suci, R, AUTN, HRES_s, K_SEAF, RES_s) ]


//--------------------------------------------------------------------------------//
//                                  Restrictions                                  //
//--------------------------------------------------------------------------------//


restriction Equality:
"All x y #i. Eq(x,y) @i ==> x = y"

restriction Inequality:
"All x y #i. Neq(x,y) @i ==> not (x = y)"

restriction GreaterThan:
" All x y #i. GreaterThan(x,y)@i ==> Ex z. x = y + z "

restriction SmallerOrEqualThan:
" All x y #i. SmallerOrEqualThan(x,y)@i ==> not ( Ex z. x = y + z ) "


//--------------------------------------------------------------------------------//
//                                     Lemmas                                     //
//--------------------------------------------------------------------------------//


lemma executable_initialization: 
  exists-trace
    "Ex M1 M2 #i #j.
       StartExchange(M1) @i & EndInitialization(M2) @j"

lemma executable_expected_response:
  exists-trace
    "Ex M1 M2 #i #j.
       StartExchange(M1) @i & EndExpectedResponse(M2) @j"

lemma executable_synchronization_failure:
  exists-trace
    "Ex M1 M2 #i #j.
       StartExchange(M1) @i & EndSynchronizationFailure(M2) @j"

lemma executable_mac_failure:
  exists-trace
    "Ex M1 M2 #i #j.
       StartExchange(M1) @i & EndMacFailure(M2) @j"

lemma secrecy_HN:
  "All x #i. 
    Secret(x) @i& Station('HN') @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma secrecy_UE:
  "All x #i. 
    Secret(x) @i& Station('UE') @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

end
